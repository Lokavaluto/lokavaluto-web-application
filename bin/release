#!/bin/bash


RELEASE_INFO_URL=${RELEASE_INFO_URL:-https://docker.0k.io/downloads/lokavaluto-releases.yml}

##
## Code is from libcommon.sh of kal-shlib-common
##

get_path() {
    (
        IFS=:
        for d in $PATH; do
            filename="$d/$1"
            [ -f "$filename" -a -x "$filename" ] && {
                echo "$d/$1"
                return 0
            }
        done
        return 1
    )
}



depends() {
    ## Avoid colliding with variables that are created with depends.
    local __i __path

    for __i in "$@"; do
        __path=$(get_path "$__i") ||
            die "dependency check: couldn't find '$__i' required command."
        export "$(echo "${__i//[- ]/_}")"="$__path"
    done
}


## appends a command to the signal handler functions
#
# example: trap_add EXIT,INT close_ssh "$ip"
trap_add() {
    local sigs="$1" sig cmd prev_cmd new_cmd
    shift || {
        echo "${FUNCNAME} usage error" >&2
        return 1
    }
    cmd="$@"

    ## Forcing the next ``$(trap -p)`` to output the current shell's
    ## traps and our parent's one. Touching any trap will switch
    ## ``trap -p`` to display the current shell traps. We choose to
    ## reset KILL signal as it can't be caught anyway.
    trap -- KILL

    while IFS="," read -d "," sig; do
        [ "$sig" ] || continue
        ##
        ## This subshell call to ``trap`` will be specially
        ## interpreted as it'll allow to query it's parent shell's
        ## traps... which means our traps.
        ##
        prev_cmd="$(trap -p "$sig")"
        if [ "$prev_cmd" ]; then
            prev_cmd=$(eval "set -- $prev_cmd"; echo "$3" )
            new_cmd="$cmd"$'\n'"${prev_cmd}"
        else
            new_cmd="$cmd"
        fi
        trap -- "$new_cmd" "$sig" || {
            echo "unable to add command '$@' to trap $sig" >&2
            return 1
        }
    done < <(echo "$sigs,")
}

settmpdir() {
    local varname="${1:-${exname}_TMPDIR}" var
    var=${!varname}
    [ "$var" ] && {
        debug 'Use given $'"$varname"' variable ('"$var"')'
        return 0
    }
    declare -g $varname=$(mktemp -d)
    trap_add EXIT "rm -rf \"${!varname:?}\" ; debug \"destructed tmp dir ${!varname}.\""
    debug "Temporary directory set up, variable \$$varname ready."
}


prefix() {
    compat_sed 's/^/'"$*"'/'
}


ansi_color() {
    local choice="$1"

    if [ "$choice" == "tty" ]; then
        if [ -t 1 ]; then
            choice="yes"
        else
            choice="no"
        fi
    fi

    if [ "$choice" != "no" ]; then

        ANSI_ESC=$'\e['
        NORMAL="${ANSI_ESC}0m"

        GRAY="${ANSI_ESC}1;30m"
        RED="${ANSI_ESC}1;31m"
        GREEN="${ANSI_ESC}1;32m"
        YELLOW="${ANSI_ESC}1;33m"
        BLUE="${ANSI_ESC}1;34m"
        PINK="${ANSI_ESC}1;35m"
        CYAN="${ANSI_ESC}1;36m"
        WHITE="${ANSI_ESC}1;37m"

        DARKGRAY="${ANSI_ESC}0;30m"
        DARKRED="${ANSI_ESC}0;31m"
        DARKGREEN="${ANSI_ESC}0;32m"
        DARKYELLOW="${ANSI_ESC}0;33m"
        DARKBLUE="${ANSI_ESC}0;34m"
        DARKPINK="${ANSI_ESC}0;35m"
        DARKCYAN="${ANSI_ESC}0;36m"
        DARKWHITE="${ANSI_ESC}0;37m"

    else

        NORMAL=

        GRAY=
        RED=
        GREEN=
        YELLOW=
        BLUE=
        PINK=
        CYAN=
        WHITE=

        DARKGRAY=
        DARKRED=
        DARKGREEN=
        DARKYELLOW=
        DARKBLUE=
        DARKPINK=
        DARKCYAN=
        DARKWHITE=

    fi

    ansi_color="$choice"

    export SET_COL_CHAR SET_COL_STATUS SET_COL_INFO SET_COL_ELT \
           SET_BEGINCOL UP DOWN LEFT RIGHT SAVE RESTORE NORMAL \
           GRAY RED GREEN YELLOW BLUE PINK CYAN WHITE DARKGRAY \
           DARKRED DARKGREEN DARKYELLOW DARKBLUE DARKPINK DARKCYAN \
           SUCCESS WARNING FAILURE NOOP ON OFF ERROR ansi_color
}

e() { printf "%s" "$*"; }
warn() { echo "${YELLOW}Warning:$NORMAL $*" >&2 ; }
info() { echo "${BLUE}II$NORMAL $*" >&2 ; }
debug() { [ -z "$DEBUG" ] || e "$*"$'\n' >&2; }
err() { echo "${RED}Error:$NORMAL $*" >&2 ; }
die() { err "$@" ; exit 1; }
p0() { printf "%s\0" "$@"; }

read-0() {
    while [ "$1" ]; do
        IFS=$'\0' read -r -d '' "$1" || return 1
        shift
    done
}



##
## Functions
##

release:index() {
    local releases_info
    releases_info=$(curl -sL "$RELEASE_INFO_URL") || {
        echo "Error: Could not load release informations" >&2
        return 1
    }
    echo "$releases_info"
}


release:build:android:bundle() {

    depends yq

    release_info=$(e "$release_index" | yq ."$app") || return 1
    if [ "$release_info" == "null" ]; then
        err "unrecognized app id '$app', please use one of:"
        e "$release_index" | yq keys | prefix "  " >&2
        return 1
    fi

    (
        cd "$TMPDIR" || return 1

        out=$(git clone -qb "$tag" --depth 1 "$git_toplevel" "$app" 2>&1) || {
            err "Clone of '$git_toplevel' to '$dir/$app' failed:"
            e "$out" | prefix "  ${DARKRED}!${NORMAL} " >&2
            return 1
        }


        cd "$app"
        rm -rf dist public resources

        url=$(e "$release_info" | yq .data) || return 1
        out=$(curl -sL "$url" > data.zip) || {
            err "Download of '$url' failed:"
            e "$out" | prefix "  ${DARKRED}!${NORMAL} " >&2
            return 1
        }


        out=$(unzip data.zip -d data) || {
            err "Unzip of downloaded content failed:"
            e "$out" | prefix "  ${DARKRED}!${NORMAL} " >&2
            return 1
        }
        mv data/*/* . || return 1
        find . -type f -name .DS_\* -delete || return 1


        if ! out=$(cat public/config.json | jq) || [ -z "$out" ]; then
            err "Given 'public/config.json' is invalid."
            return 1
        fi

        app_dn=$(e "$release_info" | yq .app.id)
        app_name=$(e "$release_info" | yq .app.name)

        cat <<EOF > capacitor.config.ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: '$app_dn',
  appName: "$app_name",
  webDir: 'dist',
  bundledWebRuntime: false
};

export default config;
EOF
        if [ "$app_dn" != 'com.lokavaluto.monujo' ]; then
            grep -rF 'com.lokavaluto.monujo' | cut -f 1 -d: | uniq | while read fmatch; do
                compat_sed_i 's/com\.lokavaluto\.monujo/'"${app_dn}"'/g' "$fmatch"
            done &&
                mkdir -p 'android/app/src/main/java/'${app_dn//./\/} &&
                mv android/app/src/main/java/*/lokavaluto/monujo/MainActivity.java \
                   'android/app/src/main/java/'${app_dn//./\/} &&
                find 'android/app/src/main/java' -depth -type d -empty -delete
        fi
        npm ci || {
            err "Unexpected failure of 'npm ci'."
            return 1
        }

        npx cordova-res android --skip-config --copy || {
            err "Unexpected failure of 'npx cordova-res android --skip-config --copy'."
            return 1
        }

        ## cf: https://github.com/ionic-team/capacitor-assets/issues/110#issuecomment-889076638
        compat_sed_i 's/@color\//@mipmap\//g' android/app/src/main/res/mipmap-anydpi-v26/ic_launcher*.xml || {
            err "Unexpected failure from sed on workaround of capacitor bug"
            return 1
        }

        for dir in android/app/src/main/res/mipmap-*dpi*; do
            [[ "$dir" == *"anydpi"* ]] && continue
            [ "$(find "$dir" -maxdepth 1 -mindepth 1 -type f -name '*.png' | wc -l )" == 0 ] && {
                err "Checking for image file in '$dir' gave no results."
                return 1
            }
        done

        mkdir -p public/i18n &&
        npm run gettext:compile || return 1

        npm run build || return 1
        npx cap sync || return 1

        compat_sed_i 's/^(\s+versionCode\s+).*$/\1'"$version_code"'/g;
         s/^(\s+versionName\s+).*$/\1'"'$tag'"'/g' \
            android/app/build.gradle

        ( cd android && ./gradlew bundle ) || return 1

        mv ./android/app/build/outputs/bundle/release/{app-release,${app}_${tag}_${version_code}}.aab || return 1

        e "$RELEASE_KEYSTORE" > android/release.jks.base64 || return 1
        base64 -d android/release.jks.base64 > android/release.decrypted.jks || return 1

        jarsigner -keystore android/release.decrypted.jks \
                  -storepass "$RELEASE_KEYSTORE_PASSWORD" \
                  -signedjar "./android/app/build/outputs/bundle/release/${app}_${tag}_${version_code}-signed.aab" \
                  "./android/app/build/outputs/bundle/release/${app}_${tag}_${version_code}.aab" lokakey0 || return 1


        if ! bundletool=$(type -p bundletool) || ! [ -x "$bundletool" ]; then
            mkdir -p bin
            wget https://github.com/google/bundletool/releases/download/1.11.2/bundletool-all-1.11.2.jar \
                 -O bin/bundletool.jar || return 1
            cat <<EOF > bin/bundletool
#!/bin/bash

exec java -jar $PWD/bin/bundletool.jar "\$@"

EOF
            chmod +x bin/bundletool
            bundletool=bin/bundletool
        fi

        mkdir -p apks
        "$bundletool" \
            build-apks \
            --bundle="./android/app/build/outputs/bundle/release/${app}_${tag}_${version_code}-signed.aab" \
            --mode=universal \
            --output="./apks/output.apks" \
            --ks=android/release.decrypted.jks \
            --ks-pass="pass:$RELEASE_KEYSTORE_PASSWORD" \
            --ks-key-alias=lokakey0 \
            --key-pass="pass:$RELEASE_KEYSTORE_PASSWORD" || return 1

        cd apks
        mv output.{apks,zip} &&
        unzip output.zip &&
        rm output.zip toc.pb &&
        mv universal.apk "${app}_${tag}_${version_code}.apk"
    )

}


release:build:web() {

    app=monujo
    release_file_name="${app}_${tag}.tar.bz2"
    result_file_path="release/$tag/${release_file_name}"
    if [ -e "$result_file_path" ]; then
        if [ -z "$force" ]; then
            warn "Release file of $app already exists in '$result_file_path'."
            echo "  Ignoring build. If you want to overwrite it, provide '-f' or '--force'." >&2
            to_publish+=("$result_file_path""#Web (tar.bz2) - ${tag}")
            return 0
        else
            info "Existing release file for $app '$result_file_path' will be overwritten."
        fi
    fi
    (
        settmpdir TMPDIR
        (
            cd "$TMPDIR" || return 1

            out=$(git clone -qb "$tag" --depth 1 "$git_toplevel" "_web" 2>&1) || {
                err "Clone of '$git_toplevel' to '$dir/$app' failed:"
                e "$out" | prefix "  ${DARKRED}!${NORMAL} " >&2
                return 1
            }

            cd "_web"
            npm ci || {
                err "Unexpected failure of 'npm ci'."
                return 1
            }

            npm run gettext:compile || return 1

            npm run build || return 1
        )

        mkdir -p "${result_file_path%/*}"
        ( cd "$TMPDIR/_web/dist" ; tar cj . ) > "$result_file_path"
    )
    to_publish+=("$result_file_path""#Web (tar.bz2) - ${tag}")
}


release:build:android() {

    rev="${rev:-0}"
    if ! [[ "$rev" =~ ^[0-9]+$ ]]; then
        err "Incorrect rev id '$rev' specified"
        exit 1
    fi

    version_code=$(bin/tag2vc "$tag" "$rev") || {
        err "Invalid tag syntax '$tag'"
        return 1
    }
    release_index=$(release:index) || return 1

    if [ -z "$RELEASE_KEYSTORE" ]; then
        keystore=${keystore:-keys/keystore}
        [ -r "$keystore" ] && {
            RELEASE_KEYSTORE=$(cat "$keystore" | base64) || return 1
        }
    fi

    if [ -z "$RELEASE_KEYSTORE_PASSWORD" ]; then
        keystore_password_file=${keystore_password_file:-keys/keystore-password}
        [ -r "$keystore_password_file" ] && {
            RELEASE_KEYSTORE_PASSWORD=$(cat "$keystore_password_file") || return 1
        }
    fi

    if [ -z "$RELEASE_KEYSTORE" ]; then
        err "Keystore not found. Please provide either:"
        cat <<EOF
 - a \$RELEASE_KEYSTORE environment variable to the base64 content
   of your keystore"
 - use '--keystore FILE' to provide path to a binary keystore" >&2

Note that, by default, a key-store file is looked up in:
  keys/keystore
EOF
        return 1
    fi


    if [ -z "$RELEASE_KEYSTORE_PASSWORD" ]; then
        err "Keystore password not found. Please provide either:"
        cat <<EOF
 - a \$RELEASE_KEYSTORE_PASSWORD environment variable holding the password
 - use '--keystore-password PASSWORD' to provide the password" >&2
 - use '--keystore-password-file FILE' to provide a file containing
   the password" >&2

Note that by default, a keystore password file is looked up in:
  keys/keystore-password
EOF
        return 1
    fi

    if [ "${#apps[@]}" == 0 ]; then
        apps=($(e "$release_index" | yq 'keys | join(" ")'))
    fi

    OUTPUT_RELATIVE_PATH="android/app/build/outputs/bundle/release/"
    settmpdir TMPDIR
    for app in "${apps[@]}"; do

        release_file_name="${app}_${tag}_${version_code}.aab"
        output="$TMPDIR/$app/$OUTPUT_RELATIVE_PATH/${release_file_name%.aab}-signed.aab"
        result_file_path="release/$tag/${release_file_name}"
        result_file_label="${app} - $tag ($version_code)"
        if [ -e "$result_file_path" ]; then
            if [ -z "$force" ]; then
                warn "Release file of $app already exists in '$result_file_path'."
                echo "  Ignoring build. If you want to overwrite it, provide '-f' or '--force'." >&2
                to_publish+=("$result_file_path""#Android Bundle (AAB) - $result_file_label")
                if [ -e "${result_file_path%.aab}.apk" ]; then
                    to_publish+=("${result_file_path%.aab}.apk""#Android App (APK) - $result_file_label")
                fi
                continue
            else
                info "Existing release file for $app '$result_file_path' will be overwritten."
            fi
        fi
        cat <<EOF

===================================
Make android $app release ..
-----------------------------------

EOF
        release:build:android:bundle "$app"
        if [ "$?" == 0 ]; then
            cat <<EOF
-----------------------------------
  .. release $app built with SUCCESS
===================================

EOF
            mkdir -p "${result_file_path%/*}"
            mv "$output" "$result_file_path" || return 1
            to_publish+=("$result_file_path""#Android Bundle (AAB) - $result_file_label")
            mv "$TMPDIR/$app/apks/${release_file_name%.aab}.apk" "${result_file_path%.aab}.apk"
            to_publish+=("${result_file_path%.aab}.apk""#Android App (APK) - $result_file_label")
        else
            cat <<EOF
----------------------------------
  .. release $app build FAILED
==================================

EOF
            return 1
        fi

    done
}


changelog:make() {

    if [[ "$tag" == *"-rc."* ]]; then
        ## Release candidate mode
        title="Release candidate $tag"
        prev=$(
            git tag | grep -E "^[0-9]+\.[0-9]+\.[0-9]+(-rc\.[0-9]+)?$" | \
                xargs semver | grep -F "$tag" -B 1 | head -n 1
            )
    else
        ## Release mode
        title="Release $tag"
        prev=$(
            git tag | grep -E "^[0-9]+\.[0-9]+\.[0-9]+$" | \
                xargs semver | grep -F "$tag" -B 1 | head -n 1
            )
    fi
    echo "$title"$'\n' > "release/${tag}/CHANGELOG"
    gitchangelog "$prev".."$tag" | tail -n +2 >> "release/${tag}/CHANGELOG"

}


##
## Code
##

ansi_color tty

git_toplevel="$(git rev-parse --show-toplevel)" || {
    err "Not in a git repository ? (git toplevel not found)."
    exit 1
}


if ! [ -e package.json ] && [ -x "bin/tag2vc" ]; then
    err "Please run this executable in the root of monujo folder."
    return 1
fi


exname="${0#*/}"
usage="$exname [-h|--help]
$exname [-t TAG|--tag TAG] [-f|--force] [-p|--platform PLATFORM]

    ## android build options:

    [-r REV|--rev REV] [-a APP|--app APP]
    [--keystore-password PASSWORD] [--keystore-password-file FILE]
    [--keystore FILE]

    ## publish options

    [-P|--publish] [-d|--draft]

"

## BSD / GNU sed compatibility layer
if get_path sed >/dev/null; then
    if sed --version >/dev/null 2>&1; then  ## GNU
        compat_sed() { sed -r "$@"; }
        compat_sed_i() { sed -r -i "$@"; }
    else                                    ## BSD
        compat_sed() { sed -E "$@"; }
        compat_sed_i() { sed -E -i "" "$@"; }
    fi
else
    ## Look for ``gsed``
    if (get_path gsed && gsed --version) >/dev/null 2>&1; then
        compat_sed() { gsed -r "$@"; }
        compat_sed_i() { gsed -r -i "$@"; }
    else
        die "$exname: required GNU or BSD sed not found"
    fi
fi
export -f compat_sed compat_sed_i


SUPPORTED_PLATFORMS=(android web)

rev=
tag=
force=
publish=
draft=
keystore=
keystore_password=
keystore_password_file=
apps=()
platforms=()
while [ "$#" != 0 ]; do
    case "$1" in
        "--help"|"-h")
            e "$usage"$'\n'
            exit 0
            ;;
        "-t"|"--tag")
            tag="$2"
            shift
            ;;
        "-P"|"--publish")
            publish="1"
            ;;
        "-d"|"--draft")
            draft="1"
            ;;
        "-r"|"--rev")
            rev="$2"
            shift
            ;;
        "-p"|"--platform")
            platforms_add=()
            if [[ "$2" == *","* ]]; then
                platforms_add+=(${2//,/ })
            else
                platforms_add+=("$2")
            fi
            shift
            for p in "${platforms_add[@]}"; do
                if [[ " ${SUPPORTED_PLATFORMS[*]} " == *" $p "* ]]; then
                    platforms+=("$p")
                else
                    err "Invalid platform '$p' (should be one of:" \
                        "$(e "${SUPPORTED_PLATFORMS[*]}" | compat_sed 's/ /, /g'))"
                    exit 1
                fi
            done
            ;;
        "-f"|"--force")
            force=1
            ;;
        "--keystore")
            [ -r "$2" ] || {
                err "Can't read file '$2'."
                exit 1
            }
            keystore="$2"
            ## will fill that later, must ensure that we superseed
            ## environment variable
            RELEASE_KEYSTORE=
            shift
            ;;
        "--keystore-password")
            keystore_password="$2"
            ## will fill that later, must ensure that we superseed
            ## environment variable
            RELEASE_KEYSTORE_PASSWORD=$keystore_password
            shift
            ;;
        "--keystore-password-file")
            keystore_password_file="$2"
            shift
            ;;
        "-a"|"--app")
            if [[ "$2" == *","* ]]; then
                apps+=(${2//,/ })
            else
                apps+=("$2")
            fi
            shift
            ;;
        *)
            err "Unexpected argument '$1'."
            e "$usage"$'\n' >&2
            exit 1
            ;;
    esac
    shift
done

depends jq jarsigner gitchangelog semver

## Args

if [ "${#platforms[@]}" == 0 ]; then
    platforms=("${SUPPORTED_PLATFORMS[@]}")
fi

if [ -z "$tag" ]; then
    tag=$(git describe --tags --exact-match) || {
        err "Can't infer current tag. Are you on a tagged commit ?"
        exit 1
    }
fi


for platform in "${platforms[@]}"; do
    release:build:"$platform"
done


changelog:make

hub:find:release() {
    local tag="$1"
    if hub release show "$tag" >/dev/null 2>&1; then
        echo "$tag"
        return 0
    fi
    untagged_releases=($(hub release -d | egrep "^untagged-[0-9a-f]{20,20}$"))
    [ "${#untagged_releases[@]}" == 0 ] && return 1
    for untagged_release in "${untagged_releases[@]}"; do
        title=$(hub release show "$untagged_release" -f %t)
        if [[ "$title" == *"$tag" ]]; then
            echo "$untagged_release"
            return 0
        fi
    done
    return 1
}

if [ -n "$publish" ]; then
    depends hub
    opts=()
    if release_id=$(hub:find:release "$tag"); then
        action=edit
        downloads=($(hub release show  -f "%as" "$release_id" | compat_sed 's%^.*/%%g'))
        state=$(hub release show -f "%S" "$release_id")
    else
        release_id="$tag"
        action=create
        downloads=()
    fi
    if [ -n "$draft" ]; then
        opts+=("-d")
    else
        if [ "$action" == "edit" -a "$state" == "draft" ]; then
            opts+=("--draft=false")
        fi
    fi
    if [[ "$tag" == *"-rc."* ]]; then
        opts+=("-p")   ## pre-release
    fi
    for asset_label in "${to_publish[@]}"; do
        asset=${asset_label%#*}
        if [[ " ${downloads[*]} " == *" ${asset##*/} "* ]]; then
            warn "Already have asset '${asset##*/}'. Ignoring."
        else
            opts+=("-a" "${asset_label}")
        fi
    done
    cmd=(hub release "$action" "${opts[@]}" -F release/"$tag"/CHANGELOG "$release_id")
    echo Launching: "${cmd[@]}"
    "${cmd[@]}"
fi